# Symbol

## 1.概述

ES5 的对象属性明都是字符串, 容易造成属性名的冲突.

ES6 引入了新的原始数据类型`Symbol`, 表示独一无二的值. 是 JavaScript 的第七种数据类型.

Symbol 值都通过`Symbol`函数生成. 也就是说, 对象的属性名现在有两种类型, 一种是字符串, 一种是新增的 Symbol 类型. 凡是属性名属于 Symbol 类型就是独一无二的, 不会与其他属性名产生冲突.

```js
const s = Symbol("s");
typeof s; // 'symbol'
```

注意, Symbol 函数不能使用`new`命令, 否则会报错. 这是因为`Symbol`函数生成的是一个原始类型的值, 不是对象.

`Symbol`函数接受一个字符串作为参数, 表示对 Symbol 实例的描述, 为了在控制台显式, 或者转为字符串时比较容易区分. 如果参数是一个对象, 会调用该对象的`toString()`方法, 将其转为字符串, 然后才生成一个 Symbol 值.

```js
const obj = {
  toString() {
    return "abc";
  },
};
let s1 = Symbol("foo");
let s2 = Symbol("bar");
let s3 = Symbol(null);
let s4 = Symbol(undefined);
let s5 = Symbol(obj);

s1; // Symbol(foo)
s2; // Symbol(bar)
s3; // Symbol(null)
s4; // Symbol()
s5; // Symbol(abc)

s1.toString(); // "Symbol(foo)"
s2.toString(); // "Symbol(bar)"
s3.toString(); // "Symbol(null)"
s4.toString(); // "Symbol()"
s5.toString(); // "Symbol(abc)"
```

注意, `Symbol`函数的参数只是表示对当前 Symbol 值得描述, 因此相同参数的`Symbol`函数的返回值也是不相等的.

```js
// 没有参数的情况
let s1 = Symbol();
let s2 = Symbol();

s1 === s2; // false

// 有参数的情况
let s1 = Symbol("foo");
let s2 = Symbol("foo");

s1 === s2; // false
```

Symbol 值不能与其他类型的值进行运算, 会报错.

```js
let sym = Symbol("My symbol");

"your symbol is " + sym;
// TypeError: can't convert symbol to string
`your symbol is ${sym}`;
// TypeError: can't convert symbol to string
```

Symbol 值可以转为布尔值, 但是不能转为数值

```js
let sym = Symbol();
Boolean(sym); // true
!sym; // false

Number(sym); // TypeError: Cannot convert a Symbol value to a number
sym + 2; // TypeError: Cannot convert a Symbol value to a number
```

## 2.Symbol.prototype.description

创建 Symbol 类型的值得时候可以添加一个描述, 获取这个描述可以调用`toString()`将 Symbol 值转为字符串.

ES2019 提供了一个实例属性`description`, 直接返回 Symbol 的描述.

```js
const sym = Symbol("foo");
String(sym); // "Symbol(foo)"
sym.toString(); // "Symbol(foo)"

// ES2019
sym.description; // "foo"
```

## 3.作为属性名的Symbol

https://es6.ruanyifeng.com/#docs/symbol#%E4%BD%9C%E4%B8%BA%E5%B1%9E%E6%80%A7%E5%90%8D%E7%9A%84-Symbol
